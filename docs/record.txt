å¯ä»¥ç¼–è¯‘æˆåŠŸçš„ï¼š
/opt/gcc-arm-10.2-2020.11-x86_64-aarch64-none-linux-gnu/bin/aarch64-none-linux-gnu-gcc \
--sysroot=/opt/sysroot_debian11 \-o sdl2_demo sdl2_demo.c \
-I/opt/sdl2-rk3588-install/include \
-L/opt/sdl2-rk3588-install/lib \
-Wl,-rpath-link=/opt/sysroot_debian11/usr/lib/aarch64-linux-gnu \
-lSDL2 -lgbm

// fusion_context.h
#ifndef FUSION_CONTEXT_H
#define FUSION_CONTEXT_H

#include <pthread.h>
#include <stdint.h>

#define THERMAL_ROWS 32
#define THERMAL_COLS 32
#define MIX_WIDTH 640
#define MIX_HEIGHT 480
#define YUV_FRAME_SIZE (MIX_WIDTH * MIX_HEIGHT * 3 / 2)

typedef struct {
    uint16_t thermal_data[THERMAL_ROWS][THERMAL_COLS];
    pthread_mutex_t mutex;
    pthread_cond_t cond;
    int updated;
} ThermalBuffer;

typedef struct {
    uint8_t yuv_data[YUV_FRAME_SIZE];
    pthread_mutex_t mutex;
    pthread_cond_t cond;
    int updated;
} YuvBuffer;

typedef struct {
    uint16_t fused_thermal[THERMAL_ROWS][THERMAL_COLS];
    uint8_t fused_yuv[YUV_FRAME_SIZE];
    pthread_mutex_t mutex;
    pthread_cond_t cond;
    int updated;
} FusionBuffer;

typedef struct {
    ThermalBuffer thermal_buf;
    YuvBuffer yuv_buf;
    FusionBuffer fusion_buf;
} FusionContext;

#endif

// threads.h
#ifndef THREADS_H
#define THREADS_H

#include "fusion_context.h"

void* thermal_thread(void* arg);
void* camera_thread(void* arg);
void* fusion_thread(void* arg);
void* display_thread(void* arg);

#endif

// threads.c
#include <stdio.h>
#include <string.h>
#include "threads.h"

void* thermal_thread(void* arg) {
    FusionContext* ctx = (FusionContext*)arg;
    while (1) {
        // æ¨¡æ‹Ÿè¯»å–çƒ­æˆåƒæ•°æ®
        pthread_mutex_lock(&ctx->thermal_buf.mutex);
        memset(ctx->thermal_buf.thermal_data, 0, sizeof(ctx->thermal_buf.thermal_data));
        ctx->thermal_buf.updated = 1;
        pthread_cond_signal(&ctx->thermal_buf.cond);
        pthread_mutex_unlock(&ctx->thermal_buf.mutex);
        usleep(33000);
    }
    return NULL;
}

void* camera_thread(void* arg) {
    FusionContext* ctx = (FusionContext*)arg;
    while (1) {
        // æ¨¡æ‹Ÿè¯»å–æ‘„åƒå¤´æ•°æ®
        pthread_mutex_lock(&ctx->yuv_buf.mutex);
        memset(ctx->yuv_buf.yuv_data, 128, sizeof(ctx->yuv_buf.yuv_data));
        ctx->yuv_buf.updated = 1;
        pthread_cond_signal(&ctx->yuv_buf.cond);
        pthread_mutex_unlock(&ctx->yuv_buf.mutex);
        usleep(33000);
    }
    return NULL;
}

void* fusion_thread(void* arg) {
    FusionContext* ctx = (FusionContext*)arg;
    while (1) {
        pthread_mutex_lock(&ctx->thermal_buf.mutex);
        while (!ctx->thermal_buf.updated)
            pthread_cond_wait(&ctx->thermal_buf.cond, &ctx->thermal_buf.mutex);
        pthread_mutex_unlock(&ctx->thermal_buf.mutex);

        pthread_mutex_lock(&ctx->yuv_buf.mutex);
        while (!ctx->yuv_buf.updated)
            pthread_cond_wait(&ctx->yuv_buf.cond, &ctx->yuv_buf.mutex);
        pthread_mutex_unlock(&ctx->yuv_buf.mutex);

        pthread_mutex_lock(&ctx->fusion_buf.mutex);
        memcpy(ctx->fusion_buf.fused_thermal, ctx->thermal_buf.thermal_data, sizeof(ctx->fusion_buf.fused_thermal));
        memcpy(ctx->fusion_buf.fused_yuv, ctx->yuv_buf.yuv_data, sizeof(ctx->fusion_buf.fused_yuv));
        ctx->fusion_buf.updated = 1;
        pthread_cond_signal(&ctx->fusion_buf.cond);
        pthread_mutex_unlock(&ctx->fusion_buf.mutex);
    }
    return NULL;
}

void* display_thread(void* arg) {
    FusionContext* ctx = (FusionContext*)arg;
    while (1) {
        pthread_mutex_lock(&ctx->fusion_buf.mutex);
        while (!ctx->fusion_buf.updated)
            pthread_cond_wait(&ctx->fusion_buf.cond, &ctx->fusion_buf.mutex);
        ctx->fusion_buf.updated = 0;
        pthread_mutex_unlock(&ctx->fusion_buf.mutex);

        // ä½¿ç”¨ OpenCV æ˜¾ç¤º ctx->fusion_buf.fused_thermal ä¸ fused_yuv
        // cv_show_heimann_classic(ctx->fusion_buf.fused_thermal);
        // draw_roi_frame(ctx->fusion_buf.fused_yuv);
    }
    return NULL;
}

// main.c
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include "threads.h"

int main(int argc, char *argv[]) {
    FusionContext ctx = {0};

    pthread_mutex_init(&ctx.thermal_buf.mutex, NULL);
    pthread_cond_init(&ctx.thermal_buf.cond, NULL);

    pthread_mutex_init(&ctx.yuv_buf.mutex, NULL);
    pthread_cond_init(&ctx.yuv_buf.cond, NULL);

    pthread_mutex_init(&ctx.fusion_buf.mutex, NULL);
    pthread_cond_init(&ctx.fusion_buf.cond, NULL);

    pthread_t t1, t2, t3, t4;
    pthread_create(&t1, NULL, thermal_thread, &ctx);
    pthread_create(&t2, NULL, camera_thread, &ctx);
    pthread_create(&t3, NULL, fusion_thread, &ctx);
    pthread_create(&t4, NULL, display_thread, &ctx);

    pthread_join(t1, NULL);
    pthread_join(t2, NULL);
    pthread_join(t3, NULL);
    pthread_join(t4, NULL);

    return 0;
}



å®é™…å¼€å‘ä¸­å»ºè®®çš„èåˆæµç¨‹ï¼š
é™æ€ä¼ æ„Ÿå™¨ç³»ç»Ÿï¼š

å¼€å§‹é˜¶æ®µåšä¸€æ¬¡æ£‹ç›˜æ ¼æ ‡å®š

ä¿å­˜å˜æ¢çŸ©é˜µ H æˆ–ä»¿å°„å˜æ¢ M

åœ¨å®æ—¶å¤„ç†æ—¶ç”¨ cv::warpPerspective ç›´æ¥å¯¹çƒ­å›¾å˜æ¢å³å¯

åŠ¨æ€ä¼ æ„Ÿå™¨/ç§»åŠ¨å¹³å°ï¼š

ä½¿ç”¨ ORB/SIFT ç‰¹å¾æå– + é…å‡†

æˆ–è€…æ­é…å›¾åƒè·Ÿè¸ªæ–¹æ³•ï¼ˆå¦‚å…‰æµï¼‰æŒç»­æ›´æ–°å¯¹é½çŠ¶æ€

çƒ­æˆåƒå›¾åƒåˆ†è¾¨ç‡ä½ï¼š

å»ºè®®å…ˆåšæ’å€¼æ”¾å¤§ï¼ˆå¦‚åŒçº¿æ€§æ’å€¼ï¼‰ï¼Œå†åšé…å‡†å¤„ç†


é…å‡†çš„å¸¸è§æ–¹æ³•åˆ†ç±»
ğŸ“Œ ä¸€ã€åŸºäºæ‰‹å·¥æ ‡å®šçš„é…å‡†ï¼ˆæ ‡å®šæ¿/å·²çŸ¥ç»“æ„ï¼‰
é€‚ç”¨åœºæ™¯ï¼šä¼ æ„Ÿå™¨å›ºå®šã€åœºæ™¯ç¨³å®š
æ ¸å¿ƒæ€è·¯ï¼šåˆ©ç”¨ç›¸æœºæ ‡å®šæ–¹æ³•æ‰¾å‡ºä¸¤ä¸ªä¼ æ„Ÿå™¨ä¹‹é—´çš„ç©ºé—´å˜æ¢å…³ç³»ï¼ˆå†…å‚ã€å¤–å‚ï¼‰

ğŸš© å…³é”®æ­¥éª¤ï¼š
ä½¿ç”¨æ£‹ç›˜æ ¼æ ‡å®šæ¿æ‹æ‘„åŒæ­¥å›¾åƒ

å¯¹å¯è§å…‰ç›¸æœºä¸çº¢å¤–ç›¸æœºåˆ†åˆ«è¿›è¡Œæ ‡å®šï¼Œæ±‚å–ç›¸æœºå†…å‚

è®¡ç®—ä¸¤ç›¸æœºé—´çš„ç›¸å¯¹å§¿æ€ï¼ˆæ—‹è½¬çŸ©é˜µå’Œå¹³ç§»å‘é‡ï¼‰

ä½¿ç”¨é‡æŠ•å½±å˜æ¢ï¼ˆä¾‹å¦‚å•åº”çŸ©é˜µ Homographyï¼‰è¿›è¡Œå›¾åƒé…å‡†

å°†çƒ­æˆåƒå›¾åƒæˆ–å¯è§å…‰å›¾åƒé€šè¿‡å˜æ¢æ˜ å°„åˆ°ç»Ÿä¸€åæ ‡ç³»ä¸‹

ğŸ“Œ ä»£ç å‚è€ƒï¼ˆOpenCVï¼‰ï¼š
cpp
å¤åˆ¶
ç¼–è¾‘
cv::Mat H = cv::findHomography(src_pts, dst_pts); // å•åº”æ€§çŸ©é˜µ
cv::warpPerspective(thermal_img, aligned_thermal, H, visible_img.size());
ğŸ“Œ äºŒã€åŸºäºç‰¹å¾åŒ¹é…çš„é…å‡†ï¼ˆè‡ªåŠ¨åŒ–ï¼‰
é€‚ç”¨åœºæ™¯ï¼šæ— æ ‡å®šæ¿ã€å›¾åƒå†…å®¹æ¸…æ™°ï¼ˆå»ºç­‘ã€è¾¹ç¼˜ç­‰ï¼‰
å…³é”®æ€è·¯ï¼šæå–ä¸¤å¹…å›¾åƒçš„ç‰¹å¾ç‚¹ï¼Œè¿›è¡ŒåŒ¹é…åä¼°è®¡å‡ ä½•å˜æ¢

ğŸ”‘ æ­¥éª¤ï¼š
ç‰¹å¾æå–ï¼ˆå¦‚ SIFTã€ORBã€AKAZE ç­‰ï¼‰

ç‰¹å¾åŒ¹é…ï¼ˆæš´åŠ›åŒ¹é… BruteForceMatcher æˆ– FLANNï¼‰

é€šè¿‡ RANSAC æ’é™¤é”™è¯¯åŒ¹é…

ä¼°ç®—å˜æ¢çŸ©é˜µï¼ˆä»¿å°„ / å•åº”æ€§çŸ©é˜µï¼‰

ä½¿ç”¨ warpAffine æˆ– warpPerspective è¿›è¡Œå›¾åƒå˜æ¢

ğŸ“Œ ç‰¹ç‚¹ï¼š
ä¸éœ€è¦æ ‡å®šæ¿

å¯é€‚åº”ä¸€å®šçš„è¿åŠ¨æˆ–è§†è§’å˜åŒ–

å¯¹çƒ­æˆåƒå›¾åƒç‰¹å¾å¼±çš„é—®é¢˜ï¼Œè¦é€‰æ‹©åˆé€‚çš„ç‰¹å¾ï¼ˆSIFT æ¯” ORB æ›´ç¨³ï¼‰

ğŸ“Œ ä¸‰ã€æ·±åº¦å­¦ä¹ æ–¹æ³•ï¼ˆé«˜ç²¾åº¦/å¼±ç‰¹å¾ç¯å¢ƒï¼‰
é€‚ç”¨äºï¼š

çƒ­æˆåƒå›¾åƒç»†èŠ‚å°‘

ç‰¹å¾æå–å›°éš¾

åœºæ™¯å¤æ‚ã€éåˆšæ€§ç›®æ ‡

ä»£è¡¨æ–¹æ³•ï¼š
ä½¿ç”¨ CNN æå–æ·±åº¦ç‰¹å¾åå¯¹é½ï¼ˆå¦‚ D2-Net, SuperGlueï¼‰

ç«¯åˆ°ç«¯å›¾åƒé…å‡†ç½‘ç»œï¼ˆå¦‚ R2D2ã€RAFTï¼‰